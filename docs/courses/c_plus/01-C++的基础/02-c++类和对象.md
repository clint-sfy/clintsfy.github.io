---
title: C++类和对象
author: 阿源
date: 2023/02/02 21:29
categories:
 - C++基础快速入门
tags:
 - C++
 - C++基础
 - 类和对象
---
# 类和对象

## 1. 类的概述

类将数据和方法封装在一起，加以权限区分，用户只能通过公共方法 访问私有数据。

### 1、定义一个类 关键字class

类的权限分为：private、protected、public。但是在类的内部 不存在 权限之分。只是对类外有效。
如果类不涉及到继承，private、protected没有区别，都是私有属性。

```cpp
1 #include <iostream>
2
3 using namespace std;
4
5 //类Data1 是一个类型
6 class Data1
7 {
8 //类中 默认为私有
9  private:
10    int a;//不要给类中成员 初始化
11 protected://保护
12    int b;
13 public://公共
14    int c;
15 //在类的内部 不存在 权限之分
16 void showData(void)
17 {
18 cout<<a<<" "<<b<<" "<<c<<endl;
19 }
20 };

21 void test01()
22 {
23 //类实例化一个对象
24 Data1 ob;
25 //类外不能直接访问 类的私有和保护数据
26 //cout<<ob.a <<endl;
27 //cout<<ob.b <<endl;
28 cout<<ob.c <<endl;
29
30    //类中的成员函数 需要对象调用
31    ob.showData();
32 }
```

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类1.png)

## 2. 实现一个类

### 请设计一个Person类

请设计一个Person类，Person类具有name和age属性，提供初始化函数(Init)，并提供对name和age的读写函数(set，get)，但必须确保age的赋值在有效范围内(0-100),超出有效范围，则拒绝赋值，并提供方法输出姓名和年龄

```cpp
#include<string.h>
class Person
{
private:
    char mName[32];
    int mAge;
public:
    //初始化成员
    void init(char *name, int age)
    {
        strcpy(mName, name);
        if(age>=0 && age<=100)
        {
            mAge = age;
        }
        else
        {
            cout<<"年龄无效"<<endl;
        }
        return;
    }
    //设置name
    void setName(char *name)
    {
        strcpy(mName, name);
    }
    //获取name
    char *getName(void)
    {
        return mName;
    }

    //设置age
    void setAge(int age)
    {
        if(age>=0 && age<=100)
        {
            mAge = age;
        }
        else
        {
            cout<<"年龄无效"<<endl;
        }
    }
    //得到age
    int getAge(void)
    {
        return mAge;
    }

    //显示所有数据
    void showPerson(void)
    {
        cout<<mName<<" "<<mAge<<endl;
    }
};
```

### **点和圆的关系**

设计一个圆形类（AdvCircle），和一个点类（Point），计算点和圆的关系。 假如圆心坐标为x0, y0,
半径为r，点的坐标为x1, y1：
1）点在圆上：(x1-x0)(x1-x0) + (y1-y0)(y1-y0) == rr
2）点在圆内：(x1-x0)(x1-x0) + (y1-y0)(y1-y0) < rr
3）点在圆外：(x1-x0)(x1-x0) + (y1-y0)(y1-y0) > r*r

```cpp
class Point
{
private:
    int mX;
    int mY;
public:
    void setX(int x)
    {
        mX = x;
    }
    int getX(void)
    {
        return mX;
    }
    void setY(int y)
    {
        mY = y;
    }
    int getY(void)
    {
        return mY;
    }
};

class Circle
{
private:
    Point p;//对象作为类的成员变量
    int mR;
public:
    void setPoint(int x, int y)
    {
        p.setX(x);
        p.setY(y);
    }
    Point getPoint(void)
    {
        return p;
    }
    void setR(int r)
    {
        mR = r;
    }
    int getR(void)
    {
        return mR;
    }

    //判断点 在圆的位置
    int pointIsOnCircle(Point &ob)
    {
        int len = (ob.getX()-p.getX())*(ob.getX()-p.getX())+\
                (ob.getY()-p.getY())*(ob.getY()-p.getY());
        if(len == mR*mR)
        {
            return 0;
        }
        else if(len > mR*mR)
        {
            return 1;
        }
        else if(len < mR*mR)
        {
            return -1;
        }
    }
};
```

## 3. 成员函数在类外实现

```c
class Data2
{
private:
    int mA;
public:
    void setA(int a);
    int getA(void);
};
void test05()
{
    Data2 ob;
    ob.setA(10);
    cout<<ob.getA()<<endl;
}
int main(int argc, char *argv[])
{
    test05();
    return 0;
}
// 利用作用域符号
void Data2::setA(int a)
{
    mA = a;
}

int Data2::getA()
{
    return mA;
}

```

## 4.类在其他文件实现

```cpp
#ifndef DATA_H
#define DATA_H


class Data
{
private:
    int mA;
public:
    int getA(void);
    void setA(int a);
};

#endif // DATA_H
```

```cpp
#include "data.h"

int Data::getA()
{
    return mA;
}

void Data::setA(int a)
{
    mA = a;
}
```

```cpp
#include <iostream>
#include "data.h"
using namespace std;

int main(int argc, char *argv[])
{
    Data ob;
    ob.setA(100);
    cout<<ob.getA()<<endl;
    return 0;
}
```

## 5. 构造函数

### 1、构造函数的概述

构造函数 是类实例化对象的时候自动调用。

### 2、创建构造函数

构造函数名和类名称相同，不能有返回值类型（连void都不可以），可以有有参数（支持重载）,必须public权限

```c
class Data1
{
public:
    int mA;
public:
    //无参构造函数
    Data1()
    {
        mA=0;
        cout<<"无参构造函数"<<endl;
    }
}
```

类实例化对象时：先为对象开辟空间 然后才是 调用构造函数

### 3、构造函数的分类

```cpp
using namespace std;
class Data1
{
public:
    int mA;
public:
    //无参构造函数
    Data1()
    {
        mA=0;
        cout<<"无参构造函数"<<endl;
    }

    //有参构造函数
    Data1(int a)
    {
        mA=a;
        cout<<"有参构造函数 mA="<<mA<<endl;
    }

    //析构函数
    ~Data1()
    {
        cout<<"析构函数 mA="<<mA<<endl;
    }
};
```

### 4、构造函数的调用

1、如果用户不提供构造函数 编译器会自动 提供一个无参的空的构造函数。

2、如果用户提供构造函数 编译器会自动 屏蔽默认无参的构造

```cpp
void test01()
{
    //隐式调用无参构造函数（推荐）
    Data1 ob1;
    cout<<ob1.mA<<endl;
    //显示调用无参构造函数
    Data1 ob2 = Data1();

    //隐式调用有参构造函数（推荐）
    Data1 ob3(10);

    //显示调用有参构造函数
    Data1 ob4 = Data1(10);

    //匿名对象(无参)
    Data1();
    Data1(20);

    //构造函数隐式转换（类中只有一个数据成员）
    Data1 ob5 = 100; //Data ob5(100)
}
```

```cpp

```

注意：写任何一个类 无参构造， 有参构造需要实现

## 6.析构函数

当对象生命周期结束的时候 系统自动调用析构函数。
函数名和类名称相同，在函数名前加~，没有返回值类型，没有函数形参。（不能被重载）
先调用析构函数 再释放对象的空间。

```cpp
    //析构函数
    ~Data1()
    {
        cout<<"析构函数 mA="<<mA<<endl;
    }
```

```cpp
void test02()
{
    Data1 ob2(20);
    {
        Data1(200);
        Data1 ob3(30);
    }
    Data1 ob4(40);
}
// 析构函数在生命周期结束的时候释放空间
//  括号结束时  括号里的释放  由于是在栈区 后进先出
```

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类2.png)

一般情况下，空的析构函数就足够。

但是如果一个类有指针成员，这个类必须 写析构函数，释放指针成员所指向空间

```cpp
#include<stdlib.h>
#include<string.h>
class Data2
{
public:
    char *name;//指针成员
public:
    Data2()
    {
        name=NULL;
    }

    Data2(char *str)
    {
        name = (char *)calloc(1, strlen(str)+1);
        strcpy(name, str);
        cout<<"有参构造 name="<<name<<endl;
    }
    ~Data2()  // 防止内存泄漏 先释放堆区 在释放栈区的name
    {
        cout<<"析构函数name = "<<name<<endl;
        if(name != NULL)
        {
            free(name);
            name=NULL;
        }
    }
};
```

## 7.拷贝构造函数

### 1、拷贝构造的定义

拷贝构造：本质是构造函数

拷贝构造的调用时机：旧对象 初始化 新对象 才会调用拷贝构造。

```cpp
class Data4
{
public:
    int mA;
public:
#if 1
    Data4()
    {
        mA = 0;
        cout<<"无参构造 mA = "<<mA<<endl;
    }
#endif
#if 1
    Data4(int a)
    {
        mA = a;
        cout<<"有参构造 mA = "<<mA<<endl;
    }
#endif
#if 1
    Data4(const Data4 &ob)//ob就是旧对象的别名
    {
        //一旦实现 了拷贝构造 必须完成赋值动作
        mA = ob.mA;
        cout<<"拷贝构造函数"<<endl;
    }
#endif
    ~Data4()
    {
        cout<<"析构函数 mA = "<<mA<<endl;
    }
};
Data4 getObject(void)
{
    Data4 ob1(10);
    cout << "A:" << &ob1 << endl;
    return ob1;
}

void test04()
{
    Data4 ob2 = getObject();  //旧对象 初始化 为新对象
    //ob2 = ob1  这个不算  都是旧对象
    cout << "B:" << &ob2 << endl;
}
```

如果用户不提供拷贝构造 编译器会自动提供一个默认的拷贝构造（完成赋值动作--浅拷贝）

### 2、拷贝构造 和 无参构造 有参构造的关系

如果用户定义了 拷贝构造 或者有参构造 都会屏蔽无参构造。

如果用户定义了 无参构造 或者有参构造 不会屏蔽拷贝构造。

### 3、拷贝构造几种调用形式（了解）

**1、旧对象给新对象初始化 调用拷贝构造**

```cpp
1 Data4 ob1(10);
2 Data4 ob2 = ob1;
```

**2、给对象取别名 不会调用拷贝构造**

```cpp
1 Data4 ob1(10);
2 Data4 &ob2 = ob1;//不会调用拷贝构造
```

**3、普通对象作为函数参数 调用函数时 会发生拷贝构造**

实参传给形参的时候，会开辟空间  相当于旧对象给了新对象  发生了拷贝构造

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类3.png)

**4、函数返回值普通对象 （Visual Studio会发生拷贝构造）（Qtcreater,linux不会发生）**

Visual Studio会发生拷贝构造

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类4.png)

## 8. 拷贝构造的浅拷贝和深拷贝

默认的拷贝构造 都是浅拷贝。

如果类中没有指针成员， 不用实现拷贝构造和析构函数。

如果类中有指针成员， 必须实现析构函数释放指针成员指向的堆区空间，必须实现拷贝构造完成深拷贝动作

```cpp
class Data5
{
public:
    char *name;
public:
    Data5()
    {
        name=NULL;
    }
    Data5(char *str)
    {
        name = (char *)calloc(1, strlen(str)+1);
        strcpy(name, str);
        cout<<"有参构造 name="<<name<<endl;
    }
    Data5(const Data5& ob)//深拷贝
    {
         //为对象的指针成员申请独立的空间
         name = (char*)calloc(1, strlen(ob.name) + 1);
         strcpy(name, ob.name);
         cout << "拷贝构造函数" << endl;
    }
    ~Data5()
    {
        cout<<"析构函数name = "<<name<<endl;
        if(name != NULL)
        {
            free(name);
            name=NULL;
        }
    }
};
void test05()
{
    Data5 ob1("hello world\n");
    Data5 ob2 = ob1;
}

int main(int argc, char *argv[])
{
    test05();
    return 0;
}
```

设计一个类：无参构造、有参构造、析够函数、拷贝构造

## 9. 初始化列表

一个类的对象 作为另一个类的成员：成员对象

如果类中想调用成员对象的有参构造 必须使用初始化列表。

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类5.png)

```
A成员对象 B自身
A 无参构造
B 无参构造
B 析构
A 析构
```

类会自动调用成员对象的无参构造。

```c
// 初始化列表
1 B(int a, int b):ob(a)
2 {
3 
4 }
```

类想调用成员对象 有参构造 必须使用初始化列表

```c
class A
{
public:
    int mA;
public:
    A()
    {
        mA = 0;
        cout<<"A的无参构造 mA="<<mA<<endl;
    }
    explicit A(int a)
    {
        mA = a;
        cout<<"A的有参构造mA="<<mA<<endl;
    }
    ~A()
    {
        cout<<"A的析构函数 mA = "<<mA<<endl;
    }
};
```

```cpp
class B
{
public:
    int mB;
    A ob;//成员对象
public:
    B()
    {
        cout<<"B类的无参构造"<<endl;
    }
    //初始化列表 成员对象 必须使用对象名+（）
    B(int a, int b):mB(b),ob(a)
    {
        cout<<"B类的有参构造"<<endl;
    }
    ~B()
    {
       cout<<"B的析构函数"<<endl;
    }
};

void test01()
{
    B ob1(10,20);
    cout<<"mA ="<<ob1.ob.mA<<", mB ="<<ob1.mB<<endl;
}
```

## 10. 对象数组

对象数组：本质是数组 数组的每个元素是对象

```cpp
class A
{
public:
    int mA;
public:
    A()
    {
        mA = 0;
        cout<<"A的无参构造 mA="<<mA<<endl;
    }
    explicit A(int a)
    {
        mA = a;
        cout<<"A的有参构造mA="<<mA<<endl;
    }
    ~A()
    {
        cout<<"A的析构函数 mA = "<<mA<<endl;
    }
};
```

```cpp
void test02()
{
    //对象数组 每个元素都会自动调用构造和析构函数
    //对象数组不初始化  每个元素 调用无参构造
    A arr1[5];

    //对象数组的初始化 必须显示使用有参构造 逐个元素初始化
    A arr2[5]={A(10),A(20),A(30),A(40),A(50) };
    int n =sizeof(arr2)/sizeof(arr2[0]);
    int i=0;
    for(i=0;i<n;i++)
    {
        cout<<arr2[i].mA<<" ";
    }
    cout<<endl;
}
```

 

## 11. explicit关键字

explicit防止构造函数隐式转换

explicit修饰构造函数

```
1 //允许有参构造 隐式转换
2 A(int a)
3 {
4 mA = a;
5 cout<<"A的有参构造mA="<<mA<<endl;
6 }
```

```c
1 //构造函数隐式转换（类中只有一个数据成员）
2 A ob1=100;//ok  容易造成误解  本质上是A ob1（100）  不是赋值！
```

```c
1 //防止有参构造 隐式转换 
2 explicit A(int a)
3 {
4 mA = a;
5 cout<<"A的有参构造mA="<<mA<<endl;
6 }
```

```c
1 //构造函数隐式转换（类中只有一个数据成员）
2 A ob1=100;//err 转换失败
```

## 12. new和delete 堆区空间操作

### 1、new和delete操作基本类型的空间

**new和malloc   delete和free 没有区别**

**区别：**

new 不用强制类型转换

new在申请空间的时候可以 初始化空间内容

```cpp
void test01()
{
    int *p = NULL;
    //申请int空间 并初始化为100
    p = new int(100);//堆区空间
    cout<<"*p = "<<*p<<endl;  // *p=100

    delete p;
}
```

```cpp
void test02()
{
    int *arr = NULL;

    //申请数组 5个int元素
    //arr = new int[5];//堆区空间
    arr = new int[5]{10,20,30,40,50};
    int i=0;
    for(i=0;i<5;i++)
    {
        cout<<arr[i]<<" ";
    }
    cout<<endl;

    //如果new有[]  delete就必须有[]
    delete [] arr;
}
```

### 2、new和delete操作类的空间

malloc不会调用构造函数  free不会调用析构函数

new 会调用构造函数 delete调用析构函数

```cpp
#include<stdlib.h>
class A
{
public:
    int mA;
public:
    A()
    {
        cout<<"无参构造"<<endl;
    }
    A(int a)
    {
        mA = a;
        cout<<"有参构造 mA="<<mA<<endl;
    }
    ~A()
    {
        cout<<"析构函数 mA="<<mA<<endl;
    }
};
```

```cpp
void test03()
{
#if 0  //malloc free
    A *p = (A *)malloc(sizeof(A));

    p->mA = 100;
    cout<<p->mA<<endl;

    free(p);

#endif

#if 1
    A *p = new A(100);

    //p->mA = 100;
    cout<<p->mA<<endl;

    delete p;
#endif
}
```

### 3、new申请对象数组

```cpp
void test04()
{
    //每个元素 默认调用无参构造
    //A *arr = new A[5];
    A *arr = new A[5]{A(10), A(20),A(30),A(40),A(50)};

    delete  [] arr;  // 加[]  会进行5次析构
}
```

## 13. 静态成员

### 1、概念的引入

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类6.png)

类的对象 拥有独立的 普通成员数据。

static 修饰的成员 叫 静态成员。

```cpp
1 class Data
2 {
3 static int a;//静态成员数据
4 static void func()//静态成员函数
5 {
6
7 }
8 }
```

### 2、静态成员数据

static修饰的静态成员 属于类而不是对象。（所有对象 共享 一份 静态成员数据）

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类7.png)

static修饰的成员 定义类的时候 必须分配空间。

static修饰的静态成员数据 必须类中定义 类外初始化。

```cpp
#include <iostream>

using namespace std;

class Data
{
public:
    int a;//普通成员数据
    //类中定义
    static int b;//静态成员数据
};
//类外初始化
int Data::b=100;

void test01()
{
    //静态成员数据 通过类名称直接访问（属于类）
    cout<<Data::b<<endl;

    //静态成员数据 通过对象访问(共享)
    Data ob1;
    cout<<ob1.b<<endl;

    ob1.b = 200;
    Data ob2;
    ob2.b = 300;
    cout<<Data::b<<endl;//300
}
```

**案例1：使用静态成员数据 统计对象的个数**

```cpp
class Data2
{
public:
    int mA;
    static int count;
public:
    Data2()
    {
        count++;
    }
    Data2(int a)
    {
        mA = a;
        count++;
    }

    Data2(const Data2 &ob)
    {
        count++;
    }
    ~Data2()  // 析构的时候 --
    {
       count--;
    }
};
int Data2::count=0;
void test02()
{
    Data2 ob1;
    Data2 ob2(10);
    Data2 ob3 = ob2;
    cout<<"对象个数:"<<Data2::count<<endl;//3
    {
        Data2 ob4;
        Data2 ob5;
        cout<<"对象个数:"<<Data2::count<<endl;//5
    }
    cout<<"对象个数:"<<Data2::count<<endl;//3
}
```

### 3、静态成员函数

静态成员函数 是属于类 而不是对象（所有对象 共享）

```cpp
class Data3
{
private:
    int data;
    static int a;
public:
    static int getA()
    {
        data = 10;//err 静态成员函数 只能操作 静态成员数据 而data为普通成员数据
        return a;
    }
};
int Data3::a = 100;
void test03()
{
    cout<<Data3::getA()<<endl;  // 由于a是私有的，通过公共方法去实现
}

int main(int argc, char *argv[])
{
    test03();
    return 0;
}
```

## 14. 单例模式

单例模式的类 只能实例化 一个对象。
重要步骤：将构造函数私有化

```cpp
#include <iostream>

using namespace std;

class SingleTon//单例模式
{
    //构造私有化 防止实例化其他对象
private:
    SingleTon(){
        count=0;
        cout<<"构造"<<endl;
    }
    SingleTon(const SingleTon &ob){
        count=0;
    }
    ~SingleTon()
    {
        cout<<"析够"<<endl;
    }
private:
    //const防止p 在类内部 被修改指向
    static SingleTon * const p;//保存唯一的实例地址
    int count;//统计任务执行次数
public:
    static SingleTon * getSingleTon(void)//获取唯一的实例地址 静态数据只能用静态方法
    {
        return p;
    }

    //用户自定义 任务函数
    void printString(char *str)
    {
        count++;
        cout<<"当前第"<<count<<"次任务打印:"<<str<<endl;
    }
};

SingleTon *const SingleTon::p = new SingleTon;//创建唯一的实例

int main(int argc, char *argv[])
{
    //获取单例的地址
    SingleTon *p1 =SingleTon::getSingleTon();
    p1->printString("离职证明1");
    p1->printString("学历证明1");
    p1->printString("学位证明1");
    p1->printString("身份证明1");

    SingleTon *p2 =SingleTon::getSingleTon();
    p2->printString("离职证明2");
    p2->printString("学历证明2");
    p2->printString("学位证明2");
    p2->printString("身份证明2");
    return 0;
}
```

## 15. 类的存储结构

成员函数、静态成员 不占类的空间。

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类8.png)

成员函数、静态成员 是独立存储 是所有对象共享

## 16.this指针

### 1、知识点的引入

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类9.png)

### 2、普通成员函数 默认有一个this指针 指向调用该成员函数的对象

```cpp
class Data2
{
public:
    int a;
    int b;
    mutable int c;
public:
    Data2(int a, int b,int c)
    {
        this->a = a;
        this->b = b;
        this->c = c;
    }
    //const 修饰成员函数为只读（该成员函数不允许对 成员数据 赋值） mutable修饰的成员除外
    void showData(void) const
    {
        //a = 100;//err
        c=100;
        cout<<a<<" "<<b<<" "<<c<<endl;
    }
};
void test02()
{
    Data2 ob1(10,20,30);
    ob1.showData();
}
```

### 3、this来完成链式操作

```cpp
class Data1
{
public:
    Data1& myPrintf(char *str)
    {
        cout<<str<<" ";
        return *this;//返回调用该成员函数的对象
    }
};
void test01()
{
    Data1().myPrintf("hehe").myPrintf("haha").myPrintf("xixix");
}
```

## 17.const修饰成员函数

const 修饰成员函数为只读（该成员函数不允许对 成员数据 赋值） mutable修饰的成员除外

```cpp
class Data2
{
public:
    int a;
    int b;
    mutable int c;
public:
    Data2(int a, int b,int c)
    {
        this->a = a;
        this->b = b;
        this->c = c;
    }
    //const 修饰成员函数为只读（该成员函数不允许对 成员数据 赋值） mutable修饰的成员除外
    void showData(void) const   // 注意这里的const!!!!!
    {
        //a = 100;//err
        c=100;
        cout<<a<<" "<<b<<" "<<c<<endl;
    }
};
void test02()
{
    Data2 ob1(10,20,30);
    ob1.showData();
}
```

## 18. 友元 friend

类将数据和方法封装在一起 加以权限区分 用户只能通过公共方法 操作私有数据。（封装性）

友元 重要用在运算符重载上。
一个函数或者类 作为了另一个类的友元 那么这个函数或类 就可以直接访问 另一个类的私有数据。

### 1、普通全局函数 作为类的友元

```cpp
class Room
{
    friend void visiting01(Room &room); //普通全局函数 作为类的友元
private:
    string bedRoom;//卧室
public:
    string setingRoom;//客厅
public:
    Room(string bedRoom, string setingRoom)
    {
        this->bedRoom = bedRoom;
        this->setingRoom = setingRoom;
    }
};

//普通全局函数
void visiting01(Room &room)
{
    cout<<"访问了"<<room.setingRoom<<endl;
    cout<<"访问了"<<room.bedRoom<<endl;  // 有friend就可以访问
}

int main(int argc, char *argv[])
{
    Room room("刘坤卧室","刘坤客厅");
    visiting01(room);
    return 0;
}
```

### 2、类的某个成员函数 作为另一个类的友元

```cpp
class Room;//向前声明 只能说明类名称
class goodGay
{
public:
    void visiting01(Room &room);  // 有Room 要向前声明
    void visiting02(Room &room);
};

class Room
{
    friend void goodGay::visiting02(Room &room);  // 成员函数 作为另一个类的友元
private:
    string bedRoom;//卧室
public:
    string setingRoom;//客厅
public:
    Room(string bedRoom, string setingRoom)
    {
        this->bedRoom = bedRoom;
        this->setingRoom = setingRoom;
    }
};
void goodGay::visiting01(Room &room)
{
    cout<<"翰文访问了"<<room.setingRoom<<endl;
    cout<<"翰文访问了"<<room.bedRoom<<endl;
}

void goodGay::visiting02(Room &room)
{
    cout<<"好基友张三访问了"<<room.setingRoom<<endl;
   cout<<"好基友张三访问了"<<room.bedRoom<<endl;
}

int main(int argc, char *argv[])
{
    Room room("吴维的卧室","吴维的客厅");
    goodGay ob;
    ob.visiting01(room);
    ob.visiting02(room);
    return 0;
}
```

```
翰文访问了吴维的客厅
好基友张三访问了吴维的客厅
好基友张三访问了吴维的卧室
```

### 3、整个类作为 另一个类的友元

```cpp
class Room;//向前声明 只能说明类名称
class goodGay
{
public:
    void visiting01(Room &room);
    void visiting02(Room &room);
};

class Room
{
    friend class goodGay;
private:
    string bedRoom;//卧室
public:
    string setingRoom;//客厅
public:
    Room(string bedRoom, string setingRoom)
    {
        this->bedRoom = bedRoom;
        this->setingRoom = setingRoom;
    }
};


int main(int argc, char *argv[])
{
    Room room("吴维的卧室","吴维的客厅");
    goodGay ob;
    ob.visiting01(room);
    ob.visiting02(room);
    return 0;
}

void goodGay::visiting01(Room &room)
{
    cout<<"翰文访问了"<<room.setingRoom<<endl;
    cout<<"翰文访问了"<<room.bedRoom<<endl;
}

void goodGay::visiting02(Room &room)
{
    cout<<"好基友张三访问了"<<room.setingRoom<<endl;
    cout<<"好基友张三访问了"<<room.bedRoom<<endl;
}
```

```cpp
翰文访问了吴维的客厅
翰文访问了吴维的卧室
好基友张三访问了吴维的客厅
好基友张三访问了吴维的卧室
```

### 4、友元的注意

1．友元关系不能被继承。

2．友元关系是单向的，类A是类B的朋友，但类B不一定是类A的朋友。

3．友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友

### 友元案例（遥控器的类）

请编写电视机类，电视机有开机和关机状态，有音量，有频道，提供音量操作的方法，频道操作的方法。由于电视机只能逐一调整频道，不能指定频道，增加遥控类，遥控类除了拥有电视机已有的功能，再增加根据输入调台功能。

提示：遥控器可作为电视机类的友元类

```cpp
#include <iostream>

using namespace std;
class TV;
class Remote
{
private:
    TV *p;
public:
    Remote(TV *p);
    void offOrOn(void);
    void upVolume(void);
    void downVolume(void);

    void upChannel(void);
    void downChannel(void);

    void showTv(void);
    void setChannel(int channel);
};
class TV
{
   friend void Remote::setChannel(int channel);  // 遥控器要去操作TV的频道
   enum{OFF, ON};
   enum{minVol, maxVol=10};
   enum{minChan, maxChan=25};
private:
    int state;
    int volume;
    int channel;
public:
    TV()
    {
        state = OFF;
        volume = minVol;
        channel = minChan;
    }
    void offOrOn(void);
    void upVolume(void);
    void downVolume(void);

    void upChannel(void);
    void downChannel(void);

    void showTv(void);

};
```
#### offOrOn
```cpp
void TV::offOrOn()
{
    state = (state==OFF?ON:OFF);
    return;
}
```

#### upVolume

```cpp
void TV::upVolume()
{
    if(volume == maxVol)
    {
        cout<<"音量已经最大了"<<endl;
        return;
    }
    volume++;
    return;
}
```

#### downVolume

```cpp
void TV::downVolume()
{
    if(volume == minVol)
    {
        cout<<"音量已经最小了"<<endl;
        return;
    }
    volume--;
    return;
}
```

#### upChannel

```cpp
void TV::upChannel()
{
    if(channel == maxChan)
    {
        cout<<"频道已经最大了"<<endl;
        return;
    }
    channel++;
    return;
}

void TV::downChannel()
{
    if(channel == minChan)
    {
        cout<<"频道已经最小了"<<endl;
        return;
    }
    channel--;
    return;
}
```

#### showTv

```cpp
void TV::showTv()
{
    cout<<"当前电视机的状态:"<<(state==OFF?"关":"开")<<endl;
    cout<<"当前电视机的音量:"<<volume<<endl;
    cout<<"当前电视机的频道:"<<channel<<endl;
}
```

#### Remote

```cpp
Remote::Remote(TV *p)
{
    this->p = p;
}

void Remote::offOrOn()
{
    p->offOrOn();
}

void Remote::upVolume()
{
    p->upVolume();
}

void Remote::downVolume()
{
    p->downVolume();
}

void Remote::upChannel()
{
    p->upChannel();
}

void Remote::downChannel()
{
    p->downChannel();
}

void Remote::showTv()
{
    p->showTv();
}

void Remote::setChannel(int channel)
{
    p->channel = channel;
}
```

#### main

```cpp
int main(int argc, char *argv[])
{
    //实例化一个电视机
    TV tv;
    Remote re(&tv); // Remote(TV *p); 所以要传地址
    re.offOrOn();
    re.upVolume();
    re.upVolume();
    re.upVolume();
    re.setChannel(20);
    re.showTv();
    return 0;
}
```

### 5、设计动态数组类

相当于数组达到最大限度时  会自行扩充然后复制

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类10.png)

#### array.h

```cpp
#ifndef ARRAY_H
#define ARRAY_H
class Array
{
private:
    int *arr;//存放首元素地址
    int capacity;//容量
    int size;//大小
public:
    Array();
    Array(int capacity);
    Array(const Array &ob);
    ~Array();

    int getCapacity() const;
    int getSize() const;  // 不允许成员赋值！

    void printArray(void);

    //插入尾部元素
    void pushBack(int elem);
    //删除尾部元素
    void popBack(void);
    int &at(int pos);  // 访问arr[pos] 相当于 *(arr+pos) 
};

#endif // ARRAY_H
```

####  array.cpp

```cpp
#include "array.h"
#include<string.h>
#include<iostream>

using namespace std;
int Array::getCapacity() const
{
    return capacity;
}

int Array::getSize() const
{
    return size;
}

void Array::printArray()
{
    int i=0;
    for(i=0;i<size; i++)
    {
        cout<<arr[i]<<" ";
    }
    cout<<endl;
    return;
}

void Array::pushBack(int elem)
{
    //判断容器是否满
    if(size == capacity)
    {
        //申请空间
        int *tmp = new int[2*capacity];
        //将就空间的内容 拷贝到新空间
        memcpy(tmp, arr, capacity*sizeof(int));
        //释放原有的空间
        delete [] arr;
        //更新arr的空间
        arr = tmp;
        //更新容量
        capacity = 2*capacity;
    }

    arr[size]=elem;
    size++;
    return;
}

void Array::popBack()
{
    if(size == 0)
    {
        cout<<"容量为空"<<endl;
    }
    else
    {
        size--;
    }
    return;
}

int& Array::at(int pos)
{
    if(pos<0 || pos >=size)
    {
        cout<<"访问违法内存"<<endl;
        exit(-1);
    }

    return arr[pos];
}

Array::Array()
{
    capacity = 5;
    size = 0;
    arr = new int[capacity];
    //空间清0
    memset(arr, 0, sizeof(int)*capacity);
}

Array::Array(int capacity)
{
    this->capacity = capacity;
    size = 0;
    arr  = new int[capacity];
    //空间清0
    memset(arr, 0, sizeof(int)*capacity);
}

Array::Array(const Array &ob)
{
    capacity = ob.capacity;
    size = ob.size;
    //深拷贝
    arr = new int[capacity];
    memcpy(arr, ob.arr, sizeof(int)*capacity);
}

Array::~Array()
{
    if(arr != NULL)
    {
        delete [] arr;
        arr = NULL;
    }
}
```

#### main.h

```cpp
#include <iostream>
#include "array.h"
using namespace std;

int main(int argc, char *argv[])
{
    Array ob;
    cout<<ob.getCapacity()<<" "<<ob.getSize()<<endl;

    ob.pushBack(10);
    ob.pushBack(20);
    ob.pushBack(30);
    ob.pushBack(40);
    ob.printArray();
    cout<<ob.getCapacity()<<" "<<ob.getSize()<<endl;
    ob.pushBack(50);
    ob.pushBack(60);
    ob.printArray();
    cout<<ob.getCapacity()<<" "<<ob.getSize()<<endl;
    ob.popBack();
    ob.popBack();
    ob.printArray();
    cout<<ob.getCapacity()<<" "<<ob.getSize()<<endl;

    cout<<"arr[2] = "<<ob.at(2)<<endl;
    ob.at(2) = 100;
    ob.printArray();
    return 0;
}
```

## 19. 运算符重载 operator

运算符重载 是对已有的运算符 指定新功能。不能创建新运算。

运算符重载关键字operator

**思路：**

1、弄懂运算符的运算对象的个数。（个数决定了 重载函数的参数个数）

2、识别运算符左边的运算对象 是类的对象 还是其他.

类的对象：全局函数实现（不推荐） 成员函数实现（推荐，少一个参数）

其他：只能是全局函数实现

### 1、重载<<运算符（全局函数实现） **重载输入>>**

```cpp
#include <iostream>
#include <string>
using namespace std;
class Person
{
    // 重载的话 全局函数一定要加友元！！！
    friend ostream & operator<<(ostream &out, Person ob);
    friend istream &operator>>(istream &in, Person &ob);
private:
    int num;
    string name;
    float score;
public:
    Person(){}
    Person(int num, string name, float score):num(num),name(name),score(score){}
    //成员函数重载+   lucy+bob
    Person operator+(Person ob)
    {
        Person tmp;
        tmp.num = this->num + ob.num;
        tmp.name = this->name + ob.name;
        tmp.score = this->score + ob.score;
        return tmp;
    }
    //成员函数重载==  lucy == bob
    bool operator==(Person &ob)
    {
        if(num == ob.num && name==ob.name && score==ob.score)
            return true;
        return false;
    }
    //重载后置++ operator++(a,int)
    Person operator++(int)
    {
        //先保存 旧的值
        Person old = *this;//*this == lucy

        //lucy++ ==> lucy = lucy+1
        this->num = this->num +1;
        this->name = this->name+this->name;//（自定义操作）
        this->score = this->score+1;

        return old;//返回旧值
    }
    //重载前置++ operator++(a)
    Person operator++()
    {
        //先++
        this->num = this->num +1;
        this->name = this->name+this->name;//（自定义操作）
        this->score = this->score+1;

        //后使用
        return *this;
    }
};
```

```cpp
ostream & operator<<(ostream &out, Person ob) // ostream & 输出可以进行链式操作
{
    // 输出的时候最好不要引用   Person ob
    out<<ob.num<<" "<<ob.name<<" "<<ob.score<<endl;
    return out;
}
istream &operator>>(istream &in, Person &ob)
{
    in>>ob.num>>ob.name>>ob.score;
    return in;
}

int main(int argc, char *argv[])
{
    Person lucy(100,"lucy", 88.8f);
    Person bob;
    //先++  后使用
    bob = ++lucy;//
    cout<<bob<<endl;  
    cout<<lucy<<endl; //opreator<<(count,lucy)
    return 0;
}
```

```
100 lucy 88
102 bob 99
100 lucy 88
102 bob 99
```

如果使用全局函数 重载运算符 必须将全局函数设置成友元。

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类12.png)

### 3、可以重载的运算符

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类11.png)

## 20. 强化string类

### Mystring.h

```cpp
#ifndef MYSTRING_H
#define MYSTRING_H
#include <iostream>
using namespace std;

class MyString
{
    friend ostream& operator<<(ostream &out, MyString ob);
    friend istream& operator>>(istream &in, MyString &ob);
private:
    char *str;
    int size;
public:
    MyString();
    MyString(char *str);
    MyString(const MyString &ob);
    ~MyString();
    int getSize() const;
    //成员函数重载[]
    char& operator[](int pos);
    MyString operator+(MyString ob);
    MyString operator+(char *str);

    // 将一个字符串拷贝给 当前Mystring 要深拷贝
    MyString& operator=(MyString ob);
    MyString& operator=(char *str);

    bool operator>(MyString ob);
    bool operator>(char *str);

//    bool operator<(MyString ob);
//    bool operator<(char *str);
//    bool operator==(MyString ob);
//    bool operator==(char *str);
//    bool operator!=(MyString ob);
//    bool operator!=(char *str);
};

#endif // MYSTRING_H

```

### **1、构造和析构函数**

```cpp
MyString::MyString()
{
    str=NULL;
    size=0;
}

MyString::MyString(char *str)
{
    size = strlen(str);
    this->str = new char[size+1];
    memset(this->str, 0, size+1);

    strcpy(this->str, str);
}

MyString::MyString(const MyString &ob)
{
    size = ob.size;
    str = new char[size+1];
    memset(str, 0, size+1);
    strcpy(str, ob.str);
}

MyString::~MyString()
{
    if(str != NULL)
    {
        delete [] str;
        str=NULL;
    }
}
```

### 2、重载输入输出

```cpp
//全局函数实现 <<重载
ostream& operator<<(ostream &out, MyString ob)
{
    out<<ob.str;
    return out;
}
//全局函数实现 >>重载
istream& operator>>(istream &in, MyString &ob)
{
    char buf[1024]="";
    cin>>buf;

    if(ob.str != NULL)//ob已经有字符串
    {
        delete [] ob.str;
        ob.str = NULL;
    }

    ob.size = strlen(buf);
    ob.str = new char[ob.size+1];
    memset(ob.str, 0,ob.size+1);
    strcpy(ob.str, buf);

    return in;
}
```

### 3、重载中括号运算符

```cpp
char& MyString::operator[](int pos)
{
    if(pos<0 || pos>=size)
    {
        cout<<"元素位置不合法"<<endl;
        exit(-1);
    }

    return str[pos];
}
```

### 4、重载+运算符

```cpp
MyString MyString::operator+(MyString ob)
{
    MyString tmp;
    tmp.size = size+ob.size;
    tmp.str = new char[tmp.size+1];
    memset(tmp.str, 0, tmp.size+1);

    strcpy(tmp.str, str);
    strcat(tmp.str, ob.str);

    return tmp;
}
MyString MyString::operator+(char *str)
{
    MyString tmp;
    tmp.size = size+strlen(str);
    tmp.str = new char[tmp.size+1];
    memset(tmp.str, 0, tmp.size+1);

    strcpy(tmp.str, this->str);
    strcat(tmp.str, str);

    return tmp;
}
```

### 5、如果有指针成员 必须重载=赋值运算符（深拷贝）

```cpp
MyString &MyString::operator=(MyString ob)
{
    //str2 = str1;
    if(this->str != NULL)
    {
        delete [] this->str;
        this->str = NULL;
    }

    this->size = ob.size;
    this->str = new char[this->size+1];
    memset(this->str, 0, this->size+1);
    strcpy(this->str, ob.str);

    return *this;
}

MyString &MyString::operator=(char *str)
{
    //str2 = str1;
    if(this->str != NULL)
    {
        delete [] this->str;
        this->str = NULL;
    }

    this->size = strlen(str);
    this->str = new char[this->size+1];
    memset(this->str, 0, this->size+1);
    strcpy(this->str, str);

    return *this;
}
```

### 6、重载>运算符

```cpp
bool MyString::operator>(MyString ob)
{
    if(str==NULL || ob.str == NULL)
    {
        exit(-1);
    }
    if(strcmp(this->str, ob.str) > 0)
    {
        return true;
    }
    return false;
}

bool MyString::operator>(char *str)
{
    if(this->str==NULL || str == NULL)
    {
        exit(-1);
    }
    if(strcmp(this->str, str) > 0)
    {
        return true;
    }
    return false;
}
```

## 21. 重载函数调用运算符()

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/类13.png)

## 22. 智能指针

智能指针：解决 堆区空间的对象 释放问题

重载* 运算符：

```cpp
#include <iostream>

using namespace std;
class Data
{
public:
    Data()
    {
        cout<<"无参构造"<<endl;
    }
    ~Data()
    {
        cout<<"析构函数"<<endl;
    }
    void func()
    {
        cout<<"func函数"<<endl;
    }
};
class SmartPointer
{
private:
    Data *p;
public:
    SmartPointer(){}
    SmartPointer(Data *p)
    {
        this->p = p;
    }
    ~SmartPointer()
    {
        delete p;
    }
    Data& operator*()
    {
       return *p;
    }
    Data* operator->()
    {
        return p;
    }
};

void test02()
{
    SmartPointer ob(new Data);
    ob.operator *().func();
    (*ob).func();

    ob.operator ->()->func();
    ob->func();
}

int main(int argc, char *argv[])
{
    test02();
    return 0;
}
```

```
无参构造
func函数
func函数
func函数
func函数
析构函数
```

## 23. 继承概述

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/继承1.png)

## 24. 子类的定义形式

```cpp
1 class 父类{};
2 class 子类:继承方式 父类名
3 {
4 //新增子类数据
5 };
```

继承方式：private protected public(推荐)

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/继承2.png)

公共继承 保持不变，保护继承变保护，私有继承变私有，所有父类私有在子类中不可见

```cpp
#include <iostream>

using namespace std;
class Base
{
public:
    int a;
public:
    Base()
    {
        cout<<"父类默认构造"<<endl;
    }
    Base(int a)
    {
        this->a = a;
        cout<<"父类有参构造"<<endl;
    }
    ~Base()
    {
        cout<<"父类析够"<<endl;
    }
};
class Son:public Base
```

## 25. 子类的构造析够顺序

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/继承3.png)

```cpp
#include <iostream>

using namespace std;
class Base
{
public:
    int a;
public:
    Base()
    {
        cout<<"父类默认构造"<<endl;
    }
    Base(int a)
    {
        this->a = a;
        cout<<"父类有参构造"<<endl;
    }
    ~Base()
    {
        cout<<"父类析够"<<endl;
    }
};
class Other
{
public:
    int b;
public:
    Other()
    {
        cout<<"Other默认构造"<<endl;
    }
    Other(int b)
    {
        this->b = b;
        cout<<"Other有参构造"<<endl;
    }
    ~Other()
    {
        cout<<"Other析够"<<endl;
    }
};

class Son:public Base
{
public:
    Other ob;
    int c;
public:
    Son()
    {
        cout<<"Son构造"<<endl;
    }
    //父类写类名称   成员对象用对象名
    Son(int a, int b, int c):Base(a), ob(b)
    {
        this->c = c;
        cout<<"Son有参构造"<<endl;
    }
    ~Son()
    {
        cout<<"Son析够"<<endl;
    }
};

void test01()
{
    Son ob(10,20,30);
}

int main(int argc, char *argv[])
{
    test01();
    return 0;
}
```

```
父类构造
Other构造
Son构造
Son析够
Other析够
父类析够
```

## 26. 子类调用成员对象、父类的有参构造

子类 会自动调用 成员对象、父类的默认构造。

子类 必须使用初始化列表 调用成员对象、父类的有参构造。

初始化列表时：父类写类名称 成员对象用对象名。

```cpp
#include <iostream>

using namespace std;
class Base
{
public:
    int a;
public:
    Base()
    {
        cout<<"父类默认构造"<<endl;
    }
    Base(int a)
    {
        this->a = a;
        cout<<"父类有参构造"<<endl;
    }
    ~Base()
    {
        cout<<"父类析够"<<endl;
    }
};
class Other
{
public:
    int b;
public:
    Other()
    {
        cout<<"Other默认构造"<<endl;
    }
    Other(int b)
    {
        this->b = b;
        cout<<"Other有参构造"<<endl;
    }
    ~Other()
    {
        cout<<"Other析够"<<endl;
    }
};

class Son:public Base
{
public:
    Other ob;  // 这里的成员对象  注意赋值的时候！！！
    int c;
public:
    Son()
    {
        cout<<"Son构造"<<endl;
    }
    //父类写类名称   成员对象用对象名 ！！！！ 超级重要
    Son(int a, int b, int c):Base(a), ob(b)
    {
        // this->a = a; 这里不行 这是父类的a
        this->c = c;
        cout<<"Son有参构造"<<endl;
    }
    ~Son()
    {
        cout<<"Son析够"<<endl;
    }
};

void test01()
{
    Son ob(10,20,30);
}

int main(int argc, char *argv[])
{
    test01();
    return 0;
}
```

## 27.子类和父类同名成员处理

### 1、子类和父类 同名成员数据

同名成员 最简单 最安全的处理方式：加作用域

子类默认优先访问 子类的同名成员

必须加父类作用域 访问父类的同名成员

```cpp
1 class Base
2 {
3 public:
4 int a;
5 public:
6 Base(int a)
7 {
8 this‐>a = a;
9 }
10 };
11
12 class Son:public Base
13 {
14 public:
15 int a;
16 Son(int x, int y):Base(x)
17 {
18 a = y;
19 }
20 };
21
22 void test01()
23 {
24 Son ob(10,20);
25 //子类默认优先访问 子类的同名成员
26 cout<<ob.a<<endl;
27 //必须加父类作用域 访问父类的同名成员
28 cout<<ob.Base::a<<endl;
29 }
```

```
20
10
```

### 2、子类和父类 同名成员函数

```cpp
1 class Base
2 {
3 public:
4 void fun01()
5 {
6 cout<<"Base 无参的fun01"<<endl;
7 }
8 };
9
10 class Son:public Base
11 {
12 public:
13 void fun01()
14 {
15 cout<<"Son 无参的fun01"<<endl;
16 }
17 };
18
19 void test01()
20 {
21 Son ob;
22 //子类默认优先访问 子类的同名成员
23 ob.fun01();
24 //必须加父类作用域 访问父类的同名成员
25 ob.Base::fun01();
26 }
```

```
Son无参的fun01
Base 无参的fun01
```

### 3、子类 重定义 父类的同名函数

重载：无继承，同一作用域，参数的个数、顺序、类型不同 都可重载

重定义：有继承， 子类 重定义 父类的同名函数（参数可以不同）（非虚函数）

子类一旦 重定义了父类的同名函数（不管参数是否一致），子类中都将屏蔽父类所有的同名函数。

```cpp
1 class Base
2 {
3 public:
4 void fun01()
5 {
6 cout<<"Base 无参的fun01"<<endl;
7 }
8 void fun01(int a)
9 {
10 cout<<"Base 的fun01 int"<<endl;
11 }
12 void fun01(int a, int b)
13 {
14 cout<<"Base 的fun01 int int"<<endl;
15 }
16 };
17
    
18 class Son:public Base
19 {
20 public:
21 void fun01(string a)
22 {
23 cout<<"Son 的fun01 char"<<endl;
24 }
25 };
26
27 void test01()
28 {
29 Son ob;
30 ob.fun01("hello");
31 ob.fun01();
32 ob.fun01(10);
33 ob.fun01(10,20);
34 }
```

```
Son的fun01 char
Base 无参的fun01
Base 的fun01 int
Base 的fun01 int int
```

## 28. 子类不能继承父类成员

父类的构造、析够、operator= 不能被子类 继承

## 29. 多继承

### 1、多继承的格式

```
1 class 父类1{};
2 class 父类2{};
3
4
5 class 子类:继承方式1 父类1, 继承方式2 父类2
6 {
7 //新增子类数据
8 };
```

```cpp
class Base1
{
public:
    int a;
    Base1(int a):a(a){}
};
class Base2
{
public:
    int a;
    Base2(int a):a(a){}
};

class Son:public Base1, public Base2
{
public:
    //int a;
    Son(int a, int b):Base1(a),Base2(b){}
};

void test01()
{
    Son ob(10,20);
    cout<<ob.a<<" "<<ob.b<<endl;
    //cout<<ob.a<<endl;//子类a
}
```

```
6422384 4200555
```

### 2、多继承中同名成员

```cpp
#include <iostream>

using namespace std;
class Base1
{
public:
    int a;
    Base1(int a):a(a){}
};
class Base2
{
public:
    int a;
    Base2(int a):a(a){}
};


class Son:public Base1, public Base2
{
public:
    //int a;
    Son(int a, int b):Base1(a),Base2(b){}
};

void test01()
{
    Son ob(10,20);
    //cout<<ob.a<<endl;//子类a
    cout<<ob.Base1::a<<endl;//Base1 a
    cout<<ob.Base2::a<<endl;//Base2 a
}
```

```
30
10
20
```

## 30. 菱形继承

菱形继承：有公共祖先的继承 叫菱形继承。

最底层的子类 数据 会包含多分（公共祖先的数据）

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/继承4.png)

```cpp
1 class Animal
2 {
3 public:
4 int data;
5 };
6 class Sheep :public Animal{};
7 class Tuo :public Animal {};
8 class SheepTuo:public Sheep,public Tuo{};
9 int main()
10 {
11 SheepTuo ob;
12 memset(&ob, 0, sizeof(SheepTuo));
13
14 //cout << ob.data << endl;//二义性
15 cout << ob.Sheep::data << endl;
16 cout << ob.Tuo::data << endl;
17 }
```

怎么才能只要公共祖先的一份数据呢？

## 31. 虚继承

虚继承 解决 菱形继承中 多分公共祖先数据的问题

### 1、虚继承的概述

在继承方式 前加virtual修饰

子类虚继承父类 子类只会保存一份公共数据

```
#include<iostream>
#include<string.h>
using namespace std;
class Animal
{
public:
    int data;
};
class Sheep :virtual public Animal{};
class Tuo :virtual public Animal {};
class SheepTuo:public Sheep,public Tuo{};
int main()
{
    SheepTuo ob;
    memset(&ob, 0, sizeof(SheepTuo));

    cout << ob.data << endl;
    //cout << ob.Sheep::data << endl;
    //cout << ob.Tuo::data << endl;
}
```

### 2、分析虚继承的实现原理

虚继承 会在子类中产生 虚基类指针（vbptr） 指向 虚基类表(vbtable), 虚基类表纪录的是通过该指针访问公共祖先的数据的偏移量。

注意：虚继承只能解决具备公共祖先的多继承所带来的二义性问题，不能解决没有公共祖先的多继承的.

工程开发中真正意义上的多继承是几乎不被使用，因为多重继承带来的代码复杂性远多于其带来的便利，多重继承对代码维护性上的影响是灾难性的，在设计方法上，任何多继承都可以用单继承代替。

## 32.多态的概述

静态多态（编译时多态，早绑定）：函数重载、运算符重载

动态多态（运行时多态，晚绑定）：虚函数

## 33. 虚函数

### 1、知识点引入

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/多态1.png)

父类指针（引用）保存 子类空间地址的目的 就是让算法通用。

### 2、父类指针 保存 子类空间地址（带来的问题）

```cpp
1 class Animal
2 {
3 public:
4 void speak(void)
5 {
6 cout<<"动物在说话"<<endl;
7 }
8 };
9 class Dog:public Animal
10 {
11 public:
12 void speak(void)
13 {
14 cout<<"狗在汪汪"<<endl;
15 }
16 };
17
18 void test01()
19 {
20 Animal *p = new Dog;
21 p‐>speak();
22 }
```

```
动物在说话
```

其实用户的需求：p->speak 希望等到的是“狗在汪汪” 而不是“动物在说话”。

原因在此：

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/多态2.png)

### 3、虚函数的定义：成员函数前加virtual修饰

子类重写父类的虚函数注意：有继承、子类重写父类虚函数（函数名、返回值类型、参数类型个数顺序 必须完全一致)。

```cpp
1 class Animal
2 {
3 public:
4 //虚函数
5 virtual void speak(void)
6 {
7 cout<<"动物在说话"<<endl;
8 }
9 };
10 class Dog:public Animal
11 {
12 public:
13 //子类重写 父类的虚函数
14 void speak(void)
15 {
16 cout<<"狗在汪汪"<<endl;
17 }
18 };
19 class Cat:public Animal
20 {
21 public:
22 //子类重写 父类的虚函数
23 void speak(void)
24 {
25 cout<<"猫在喵喵"<<endl;
26 }
27 };
28 void test01()
29 {
30 Animal *p1 = new Dog;
31 p1‐>speak();
32 Animal *p2 = new Cat;
33 p2‐>speak();
34
35 delete p1;
36 delete p2;
37 }
```

```
狗在汪汪
猫在喵喵
```

### 4、虚函数原理

如果一个类中的成员函数 被virtual修饰，那么这个函数就是虚函数。类就会产生一个虚函数指针（vfptr）指向了一张虚函数表（vftable）。
如果这个类 没有涉及到继承， 这时虚函数表中 纪录及时当前类的虚函数入口地址。

![](https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/img/c_plus/多态3.png)

## 34. 纯虚函数

虚函数不实现函数体：

```
1 class Animal
2 {
3 public:
4 //纯虚函数
5 virtual void speak(void)=0;
6 };
```

一旦类中有纯虚函数，那么这个类 就是抽象类。

抽象类 不能实例化 对象。（Animal ob；错误）

抽象类 必须被继承 同时 子类 必须重写 父类的所有纯虚函数，否则 子类也是抽象类。

**抽象类主要的目的 是设计 类的接口：**

```cpp
1 #include <iostream>
2
3 using namespace std;
4 //抽象制作饮品
5 class AbstractDrinking{
6 public:
7 //烧水
8 virtual void Boil() = 0;
9 //冲泡
10 virtual void Brew() = 0;
11 //倒入杯中
12 virtual void PourInCup() = 0;
13 //加入辅料
14 virtual void PutSomething() = 0;
15 //规定流程
16 void MakeDrink(){
17 this‐>Boil();
18 Brew();
19 PourInCup();
20 PutSomething();
21 }
22 };
23
24 //制作咖啡
25 class Coffee : public AbstractDrinking{
26 public:
27 //烧水
28 virtual void Boil(){
29 cout << "煮农夫山泉!" << endl;
30 }
31 //冲泡
32 virtual void Brew(){
33 cout << "冲泡咖啡!" << endl;
34 }
35 //倒入杯中
36 virtual void PourInCup(){
37 cout << "将咖啡倒入杯中!" << endl;
38 }
39 //加入辅料
40 virtual void PutSomething(){
41 cout << "加入牛奶!" << endl;
42 }
43 };
44
45 //制作茶水
46 class Tea : public AbstractDrinking{
47 public:
48 //烧水
49 virtual void Boil(){
50 cout << "煮自来水!" << endl;
51 }
52 //冲泡
53 virtual void Brew(){
54 cout << "冲泡茶叶!" << endl;
55 }
56 //倒入杯中
57 virtual void PourInCup(){
58 cout << "将茶水倒入杯中!" << endl;
59 }
60 //加入辅料
61 virtual void PutSomething(){
62 cout << "加入食盐!" << endl;
63 }
64 };
65
66 //业务函数
67 void DoBussiness(AbstractDrinking* drink){
68 drink‐>MakeDrink();
69 delete drink;
70 }
71
72 int main(int argc, char *argv[])
73 {
74 DoBussiness(new Coffee);
75 cout << "‐‐‐‐‐‐‐‐‐‐‐‐‐‐" << endl;
76 DoBussiness(new Tea);
77
78 return 0;
```

**问题1：虚函数 和纯虚函数的 区别**

虚函数：virtual修饰 有函数体 不会导致父类为抽象类。

纯虚函数：virtual修饰，=0，没有函数体 导致父类为抽象类。子类必须重写父类的所有纯虚函数。

## 35.  虚析构函数

虚析构：通过父类指针 释放整个子类空间。

```cpp
1 class Animal
2 {
3 public:
4 //虚函数
5 virtual void speak(void)
6 {
7 cout << "动物在说话" << endl;
8 }
9 //虚析构
10 virtual ~Animal()
11 {
12 cout<<"Animal的析构函数"<<endl;
13 }
14 };
15 class Dog :public Animal
16 {
17 public:
18 //子类重写 父类的虚函数
19 void speak(void)
20 {
21 cout << "狗在汪汪" << endl;
22 }
23 ~Dog()
24 {
25 cout<<"Dog的析构函数"<<endl;
26 }
27 };
28
29 void test01()
30 {
31 Animal* p1 = new Dog;
32 p1‐>speak();
33
34 delete p1;
35 }
```

```
狗在汪汪
Dog的析够函数
Animal的析够函数
```

构造的顺序：父类--->成员---->子类

析构的顺序：子类--->成员---->父类

## 36. 纯虚析构函数

纯虚析构的本质：是析构函数，各个类的回收工作。而且析构函数不能被继承。

必须为纯虚析构函数提供一个函数体。

纯虚析构函数 必须在类外实现

```cpp
1 #include <iostream>
2
3 using namespace std;
4 class Animal
5 {
6 public:
7 //纯虚函数
8 virtual void speak(void)=0;
9
10 //纯虚析构函数 必须在类外实现
11 virtual ~Animal()=0;
12 };

13 class Dog :public Animal
14 {
15 public:
16 //子类重写 父类的虚函数
17 void speak(void)
18 {
19 cout << "狗在汪汪" << endl;
20 }
21 ~Dog()
22 {
23 cout<<"Dog的析构函数"<<endl;
24 }
25 };
26
27 void test01()
28 {
29 Animal* p1 = new Dog;
30 p1‐>speak();
31
32 delete p1;
33
34 }
35
36 int main(int argc, char* argv[])
37 {
38 test01();
39 return 0;
40 }
41
42 Animal::~Animal()
43 {
44 cout<<"Animal的析构函数"<<endl;
45 }
```

**问题1：虚析构 和纯虚析构的区别？**

虚析构：virtual修饰，有函数体，不会导致父类为抽象类。

纯虚析构：virtual修饰，=0，函数体必须类外实现，导致父类为抽象类。

## 多态的常用问题

**1、多态的分类****2、谈谈你对****动态捆绑****机制的理解（虚函数实现原理）**

**3、重载、重定义、重写的区别**

**4、虚函数和纯虚函数的区别**

**5、虚析构和纯虚析构的区别**

**6、虚函数的作用**

**7、虚析构的作用**

## **重载、重定义、重写的区别**

重载：同一作用域，同名函数，参数的顺序、个数、类型不同 都可以重载。函数的返回值类型不能作为重载条件（函数重载、运算符重载）

重定义：有继承，子类 重定义 父类的同名函数（非虚函数）， 参数顺序、个数、类型可以不同。子类的同名函数会屏蔽父类的所有同名函数（可以通过作用域解决）

重写（覆盖）：有继承，子类 重写 父类的虚函数。返回值类型、函数名、参数顺序、个数、类型都必须一致
