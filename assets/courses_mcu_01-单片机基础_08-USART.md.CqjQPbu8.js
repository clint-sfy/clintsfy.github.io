import{_ as r}from"./chunks/ArticleMetadata.CXcxJ8bO.js";import{_ as c,C as d,c as i,o as s,k as l,G as T,P as h,a as R,w as S,b as u,e as m}from"./chunks/framework.CrIyLpqU.js";import"./chunks/md5.qV03bT1e.js";const X=JSON.parse('{"title":"USART","description":"","frontmatter":{"title":"USART","author":"阿源","date":"2024/02/15 16:30","categories":["MCU"],"tags":["MCU","USART"]},"headers":[],"relativePath":"courses/mcu/01-单片机基础/08-USART.md","filePath":"courses/mcu/01-单片机基础/08-USART.md","lastUpdated":1724240505000}'),A={name:"courses/mcu/01-单片机基础/08-USART.md"};function b(a,e,U,g,C,f){const p=r,n=d("ClientOnly");return s(),i("div",null,[e[0]||(e[0]=l("h1",{id:"usart",tabindex:"-1"},[R("USART "),l("a",{class:"header-anchor",href:"#usart","aria-label":'Permalink to "USART"'},"​")],-1)),T(n,null,{default:S(()=>{var t,o;return[(((t=a.$frontmatter)==null?void 0:t.aside)??!0)&&(((o=a.$frontmatter)==null?void 0:o.showArticleMetadata)??!0)?(s(),u(p,{key:0,article:a.$frontmatter},null,8,["article"])):m("",!0)]}),_:1}),e[1]||(e[1]=h(`<p>注意：在串口助手的接收模式中有文本模式和HEX模式两种模式，那么它们有什么区别？</p><p>文本模式和Hex模式是两种不同的文件编辑或浏览模式，不是完全相同的概念。文本模式通常是指以ASCII编码格式表示文本文件的编辑或浏览模式。在文本模式下，文本文件的内容以可读的字符形式显示，包括字母、数字、符号等，这些字符被转换为计算机能够识别和处理的二进制编码。</p><p>而Hex模式则是指以十六进制编码格式显示文件内容的编辑或浏览模式。在Hex模式下，文件的内容以16进制数值的形式显示，每个字节（byte）用两个十六进制数表示，从0x00到0xFF，可以查看文件的二进制编码，包括数据、指令、标志位等信息。因此，虽然文本模式和Hex模式都是用于文件编辑或浏览的模式，但它们的显示和处理方式不同，用途也不同。</p><h2 id="串口通讯" tabindex="-1">串口通讯 <a class="header-anchor" href="#串口通讯" aria-label="Permalink to &quot;串口通讯&quot;">​</a></h2><ul><li><p>串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信</p></li><li><p>单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大地扩展了单片机的应用范围，增强了单片机系统的硬件实力</p></li></ul><p>STM32如何才能获取到陀螺仪、蓝牙器等这些外挂模的数据呢？</p><p>这就需要我们在这两个设备之间，连接上一根或多根通信线，通过通信线路发送或者接收数据，完成数据交换，从而实现控制外挂模块和读取外挂模块数据的目的。所以在这里，通信的目的是，将一个设备的数据传送到另一个设备，单片机有了通信的功能，就能与众多别的模块互联，极大地扩展了硬件系统。</p><h2 id="物理层" tabindex="-1">物理层 <a class="header-anchor" href="#物理层" aria-label="Permalink to &quot;物理层&quot;">​</a></h2><p>串口通讯的物理层有很多标准及变种，我们主要讲解RS-232标准 ，RS-232标准主要规定了信号的用途、通讯接口以及信号的电平标准。</p><p>在上面的通讯方式中，两个通讯设备的“DB9接口”之间通过串口信号线建立起连接，串口信号线中使用“RS-232标准”传输数据信号。 由于RS-232电平标准的信号不能直接被控制器直接识别，所以这些信号会经过一个“电平转换芯片”转换成控制器能识别的“TTL标准”的电平信号，才能实现通讯。</p><h2 id="协议层" tabindex="-1">协议层 <a class="header-anchor" href="#协议层" aria-label="Permalink to &quot;协议层&quot;">​</a></h2><ul><li><p>波特率：串口通信的速率</p></li><li><p>起始位：标志一个数据帧的开始，固定为低电平</p></li><li><p>数据位：数据帧的有效载荷，1为高电平，0为低电平，低位先行</p></li><li><p>校验位：用于数据验证，根据数据位计算得来</p></li><li><p>停止位：用于数据帧间隔，固定为高电平</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/stm32/base/20240819151027.png" alt=""></p><p>总结一下就是，<code>TX引脚输出定时翻转的高低电平</code>，<code>RX引脚定时读取引脚的高低电平</code>。每个字节的数据加上起始位、停止位、可选的校验位，打包为数据帧，依次输出在TX引脚，另一端RX引脚依次接收，这样就完成了字节数据的传递，这就是串口通信。</p><h2 id="stm32的usart串口" tabindex="-1">STM32的USART串口 <a class="header-anchor" href="#stm32的usart串口" aria-label="Permalink to &quot;STM32的USART串口&quot;">​</a></h2><p>另外我们经常还会遇到串口，叫UART，少了个S，就是通用异步收发器，一般我们串口很少使用这个同步功能，所以USART和UART使用起来，也没有什么区别。其实这个STM32的USART同步模式，只是<code>多了个时钟输出</code>而已，它只支持时钟输出，<code>不支持时钟输入</code>，所以这个同步模式更多的是为了，兼容别的协议或者特殊用途而设计的，并不支持两个USART之间进行同步通信。所以我们学习串口，主要还是异步通信。</p><ul><li><p>USART（Universal Synchronous/Asynchronous Receiver/Transmitter）通用同步/异步收发器</p></li><li><p>USART是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去，也可自动接收RX引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里</p></li><li><p>自带波特率发生器，最高达4.5Mbits/s</p></li><li><p>可配置数据位长度（8/9）、停止位长度（0.5/1/1.5/2）</p></li><li><p>可选校验位（无校验/奇校验/偶校验）</p></li><li><p>支持同步模式、硬件流控制、DMA、智能卡、IrDA、LIN</p></li><li><p>STM32F103C8T6 USART资源： USART1、 USART2、 USART3</p></li></ul><p>这个同步模式，就是多了个时钟CLK的输出；硬件流控制，比如A设备的TX脚向B设备的RX脚发送数据，A设备一直在发，发的太快了，B处理不过来，<code>如果没有硬件流控制，那B就只能抛弃新数据或者覆盖原数据了</code>。</p><p>如果有<code>硬件流控制</code>，在硬件电路上，会多出一根线，如果B没准备好接收，就置高电平，如果准备好了，就置低电平。A接收到了B反馈的准备信号，就<code>只会在B准备好的时候，才发数据</code>，如果B没准备好，那数据就不会发送出去。这就是硬件流控制，可以防止因为B处理慢而导致数据丢失的问题。</p><p>之后DMA，是这个串口支持DMA进行数据转运，可以使用DMA转运数据，减轻CPU的负担；最后，智能卡、IrDA、LIN，这些是其他的一些协议。因为这些协议和串口是非常的像，所以STM32就对USART加了一些小改动，就能兼容这么多协议了，不过我们一般不用，像这些协议，Up主也都没用过。</p><h2 id="串口的程序框图" tabindex="-1">串口的程序框图 <a class="header-anchor" href="#串口的程序框图" aria-label="Permalink to &quot;串口的程序框图&quot;">​</a></h2><h3 id="引脚部分" tabindex="-1">引脚部分 <a class="header-anchor" href="#引脚部分" aria-label="Permalink to &quot;引脚部分&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/stm32/base/20240819153351.png" alt=""></p><p>TX： 发送数据输出引脚。</p><p>RX： 接收数据输入引脚。</p><p>SCLK： 发送器时钟输出引脚。这个引脚仅适用于同步模式。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span>SW_RX： 数据接收引脚，只用于单线和智能卡模式，属于内部引脚，没有具体外部引脚。</span></span>
<span class="line"><span>nRTS： 请求以发送(Request To Send)，n表示低电平有效。如果使能RTS流控制，当USART接收器准备好接收新数据时就会将nRTS变成低电平； 当接收寄存器已满时，nRTS将被设置为高电平。该引脚只适用于硬件流控制。</span></span>
<span class="line"><span>nCTS： 清除以发送(Clear To Send)，n表示低电平有效。如果使能CTS流控制，发送器在发送下一帧数据之前会检测nCTS引脚， 如果为低电平，表示可以发送数据，如果为高电平则在发送完当前数据帧之后停止发送。该引脚只适用于硬件流控制。</span></span></code></pre></div><h3 id="数据寄存器" tabindex="-1">数据寄存器 <a class="header-anchor" href="#数据寄存器" aria-label="Permalink to &quot;数据寄存器&quot;">​</a></h3><p>USART_DR包含了<code>已发送的数据或者接收到的数据</code>。USART_DR实际是包含了两个寄存器，一个专门<code>用于发送的可写TDR</code>， 一个专门用于<code>接收的可读RDR</code>。这两个寄存器占用同一个地址在程序上，只表现为一个寄存器。</p><p>当进行发送操作时，往USART_DR写入数据会自动存储在TDR内；当进行读取操作时，向USART_DR读取数据会自动提取RDR数据。</p><p>USART数据寄存器(USART_DR)只有低9位有效，并且第9位数据是否有效要取决于USART控制寄存器1(USART_CR1)的M位设置， 当M位为0时表示8位数据字长，当M位为1表示9位数据字长，我们一般使用8位数据字长。</p><p>TDR和RDR都是介于系统总线和移位寄存器之间。串行通信是一个位一个位传输的，发送时把TDR内容转移到发送移位寄存器， 然后把移位寄存器数据每一位发送出去，接收时把接收到的每一位顺序保存在接收移位寄存器内然后才转移到RDR。</p><h3 id="移位寄存器" tabindex="-1">移位寄存器 <a class="header-anchor" href="#移位寄存器" aria-label="Permalink to &quot;移位寄存器&quot;">​</a></h3><p>然后往下看，下面是两个移位寄存器，一个用于发送，一个用于接收。<code>发送移位寄存器的作用</code>就是，把<strong>一个字节的数据一位一位地移出去</strong>，正好对应串口协议的波形的数据位。</p><p>这两个寄存器是怎么工作的呢？（图中主要讲的是发送寄存器）</p><p>比如你在某时刻给TDR写入了0x55这个数据，在器存器里就是二进制存储，0101 0101，那么此时，硬件检测到你写入数据了，它就会检查，当前移位寄存器是不是有数据正在移位。</p><p>如果没有，这个01010101就会立刻全部移动到发送移位寄存器，准备发送，当数据从TDR移动到移位寄存器时，会置一个标志位。叫TXE (TX Empty) ，发送寄存器空，我们检查这个标志位。如果置1了，我们就可以在TDR写入下一个数据了。</p><p>然后发送移位寄存器就会在下面这里的发生器控制的驱动下，向右移位，然后一位一位地，把数据输出到TX引脚。这里是向右移位的，所以正好和串口协议规定的低位先行，是一致的，当数据移位完成后，新的数据就会再次自动地从TDR转移到发送移位寄存器里来，如果当前移位毒存器移位还没有完成，TDR的数据就会进行等待，一但移位完成，就会立刻转移过来，有了TDR和移位寄存器的双重缓存，可以保证连续发送数据的时候，数据帧之间不会有空闲。</p><p>注意一下，<code>当TXE标志位置1时，数据其实还没有发送出去</code>，只要数据从TDR转移到发送移位寄存器了，TXE就会置1，我们就可以写入新的数据了。【就是发送数据寄存器里一直有数据，而发送移位寄存器里的数据一旦移位完成，那么发送数据寄存器里的数据就会立刻传输进入发送移位寄存器里再次传输】</p><h3 id="硬件流控制" tabindex="-1">硬件流控制 <a class="header-anchor" href="#硬件流控制" aria-label="Permalink to &quot;硬件流控制&quot;">​</a></h3><p>下面这里是发送器控制，它就是用来控制发送移位寄存器的工作的；接收器控制，用来控制接收移位寄存器的工作；然后左边这里，有一个<code>硬件数据流控</code>，也就是硬件流控制，简称流控。   这里流控有两个引脚，<code>一个是nRTS，一个是nCTS</code>。nRTS（Request To Send）是请求发送，是输出脚，也就是告诉别人，我当前能不能接收；nCTS （Clear To Send）是清除发送，是输入脚，也就是用于接收别人nRTS的信号的。 <img src="https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/stm32/base/20240819155701.png" alt=""></p><p>首先，我们需要找到一个支持流控的串口，并将它的TX连接到我们的RX。同时，我们的RTS需要输出一个接收反馈信号，并将其连接到对方的CTS。当我们可以接收数据时，RTS会置为低电平，请求对方发送。对方的CTS接收到信号后，就可以继续发送数据。如果处理不过来，比如接收数据寄存器未及时读取，导致新数据无法接收，此时RTS会置为高电平，对方的CTS接收到信号后，就会暂停发送，直到接收数据寄存器被读取，RTS重新置为低电平，数据才会继续发送。</p><p>当我们的TX向对方发送数据时，对方的RTS会连接到我们的CTS，用于判断对方是否可以接收数据。TX和CTS是一对对应的信号，RX和RTS也是一对对应的信号。此外，CTS和RTS之间也需要交叉连接，这就是流控的工作模式。然而，我们一般不使用流控，因此只需要了解一下即可。（少用原因应该是多消耗两根通信线）</p><h3 id="sclk控制" tabindex="-1">SCLK控制 <a class="header-anchor" href="#sclk控制" aria-label="Permalink to &quot;SCLK控制&quot;">​</a></h3><p>接着继续看右边这个模块，这部分电路<code>用于产生同步的时钟信号</code>，它是配合发送移位寄存器输出的，发送寄存器每移位一次，同步时钟电平就跳变一个周期。时钟告诉对方，我移出去一位数据，你看要不要让我这个时钟信号来指导你接收一下？当然这个时钟只支持输出，不支持输入，所以两个USART之间，不能实现同步的串口通信。</p><p>那这个时钟信号有什么用呢？<code>兼容别的协议</code>。比如串口加上时钟之后，就跟SPI协议特别像，所以有了时钟输出的串口，<code>就可以兼容SPI</code>。另外这个时钟也可以做<code>自适应波特率</code>，比如接收设备不确定发送设备给的什么波特率，然后再计算得到波特率，不过这就需要另外写程序来实现这个功能了。这个时钟功能，我们一般不用，所以也是了解一下就行</p><h3 id="唤醒单元" tabindex="-1">唤醒单元 <a class="header-anchor" href="#唤醒单元" aria-label="Permalink to &quot;唤醒单元&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/stm32/base/20240819160139.png" alt=""></p><p>这部分的作用是实现<code>串口挂载多设备</code>。我们之前说，串口一般是点对点的通信（只支持两个设备互相通信）。而多设备，在一条总线上，可以接多个从设备，每个设备分配一个地址，我想跟某个设备通信，就先进行寻址，确定通信对象。</p><p>那回到这里，这个唤醒单元就可以用来<code>实现多设备的功能</code>，在这里可以给串口分配一个地址，当你发送指定地址时，此设备唤醒开始工作，当你发送别的设备地址时，别的设备就唤醒工作，这个设备没收到地址，就会保持沉默。这样就可以<code>实现多设备的串口通信</code>了，这部分功能我们一般不用。</p><h3 id="中断输出控制" tabindex="-1"><strong>中断输出控制</strong> <a class="header-anchor" href="#中断输出控制" aria-label="Permalink to &quot;**中断输出控制**&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/stm32/base/20240819160506.png" alt=""></p><p>中断申请位，就是状态寄存器这里的各种标志位，状态寄存器这里，有两个标志位比较重要，一个是<code>TXE发送寄存器空</code>，另一个是<code>RXNE接收寄存器非空</code>，这两个是判断<code>发送状态和接收状态</code>的必要标志位，剩下的标志位，了解一下就行。中断输出控制这里，就是配置中断是不是能通向NVIC，这个应该好理解</p><h3 id="波特率发生器部分" tabindex="-1">波特率发生器部分 <a class="header-anchor" href="#波特率发生器部分" aria-label="Permalink to &quot;波特率发生器部分&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/clint-sfy/blogcdn@master/stm32/base/20240819160745.png" alt=""></p><p>波特率发生器其实就是<code>分频器</code>，APB时钟进行分频，得到发送和接收移位的时钟。看一下，这里时钟输入是fPCLKx（x=1或2），（USART1挂载在APB2，所以就是PCLK2的时钟，一般是72M；其他的USART都挂载在APB1，所以是PCLK1的时钟，一般是36M）之后这个时钟进行一个分频，除一个USARTDIV的分频系数，并且分为了整数部分和小数部分，因为有些波特率，用72M除一个整数的话，可能除不尽，会有误差。</p><p>所以这里分频系数是支持小数点后4位的，分频就更加精准，之后分频完之后，还要再除个16，得到发送器时钟和接收器时钟，通向控制部分。然后右边这里，如果TE (TX Enable）为1，就是发送器使能了，发送部分的波特率就有效；如果RE（RX Enable）为1，就是接收器使能了，接收部分的波特率就有效。</p>`,57))])}const x=c(A,[["render",b]]);export{X as __pageData,x as default};
