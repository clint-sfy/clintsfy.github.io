import{_ as p}from"./chunks/ArticleMetadata.e10718d6.js";import{_ as c,v as t,b as r,E as i,O as d,F as n,L as u,R as h,M as k,C as g,B as P}from"./chunks/framework.2aeb816e.js";import"./chunks/md5.772bbdf1.js";const f=JSON.parse('{"title":"UDP通信","description":"","frontmatter":{"title":"UDP通信","author":"阿源","date":"2023/08/12 12:00","categories":["QT快速入门"],"tags":["C++","QT5"]},"headers":[],"relativePath":"courses/yuanzi/03-QT应用开发和部署/13-UDP通信.md","filePath":"courses/yuanzi/03-QT应用开发和部署/13-UDP通信.md","lastUpdated":1691327334000}'),b={name:"courses/yuanzi/03-QT应用开发和部署/13-UDP通信.md"},m=n("h1",{id:"正点原子qt之udp通信",tabindex:"-1"},[u("正点原子QT之UDP通信 "),n("a",{class:"header-anchor",href:"#正点原子qt之udp通信","aria-label":'Permalink to "正点原子QT之UDP通信"'},"​")],-1),Q=h(`<h2 id="_15-udp通信" tabindex="-1">15. UDP通信 <a class="header-anchor" href="#_15-udp通信" aria-label="Permalink to &quot;15. UDP通信&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#adbac7;">UDP（User Datagram Protocol 即用户数据报协议）是一个轻量级的，不可靠的，面向数据</span></span>
<span class="line"><span style="color:#adbac7;">报的无连接协议。 </span></span>
<span class="line"><span style="color:#adbac7;">但是由于 UDP 的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用 UDP 较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</span></span>
<span class="line"><span style="color:#adbac7;">QUdpSocket 类提供了一个 UDP 套接字。 QUdpSocket 是 QAbstractSocket 的子类，允许发送和接收 UDP 数据报。使用该类最常见的方法是使用 bind()绑定到一个地址和端口，然后调用writeDatagram()和 readDatagram() / receiveDatagram()来传输数据。 注意发送数据般少于 512字节。如果发送多于 512 字节的数据，即使我们发送成功了，也会在 IP 层被分片（分成小片段）。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">UDP（User Datagram Protocol 即用户数据报协议）是一个轻量级的，不可靠的，面向数据</span></span>
<span class="line"><span style="color:#24292e;">报的无连接协议。 </span></span>
<span class="line"><span style="color:#24292e;">但是由于 UDP 的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用 UDP 较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</span></span>
<span class="line"><span style="color:#24292e;">QUdpSocket 类提供了一个 UDP 套接字。 QUdpSocket 是 QAbstractSocket 的子类，允许发送和接收 UDP 数据报。使用该类最常见的方法是使用 bind()绑定到一个地址和端口，然后调用writeDatagram()和 readDatagram() / receiveDatagram()来传输数据。 注意发送数据般少于 512字节。如果发送多于 512 字节的数据，即使我们发送成功了，也会在 IP 层被分片（分成小片段）。</span></span></code></pre></div><h3 id="_15-1-udp-单播与广播" tabindex="-1">15.1 UDP 单播与广播 <a class="header-anchor" href="#_15-1-udp-单播与广播" aria-label="Permalink to &quot;15.1 UDP 单播与广播&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#adbac7;">广播 UDP 与单播 UDP 的区别就是 IP 地址不同，所以我们的实例可以写成一个。我们可以这么理解，单播实际上是通信上对应一对一，广播则是一对多（多，这里指广播地址内的所有主机）。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">广播 UDP 与单播 UDP 的区别就是 IP 地址不同，所以我们的实例可以写成一个。我们可以这么理解，单播实际上是通信上对应一对一，广播则是一对多（多，这里指广播地址内的所有主机）。</span></span></code></pre></div><h3 id="案例-udp-单播-与广播应用" tabindex="-1">案例：UDP 单播 与广播应用 <a class="header-anchor" href="#案例-udp-单播-与广播应用" aria-label="Permalink to &quot;案例：UDP 单播 与广播应用&quot;">​</a></h3><p>本例大体流程首先获取本地 IP 地址。创建一个 udpSocket 套接字， 然后绑定本地主机的端口（也就是监听端口）。 我们可以使用 QUdpSocket 类提供的读写函数 readDatagram 和 writeDatagram，知道目标 IP 地址和端口，即可完成消息的接收发送。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#adbac7;"></span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"></span></span></code></pre></div><h3 id="_15-2-udp-组播" tabindex="-1">15.2 UDP 组播 <a class="header-anchor" href="#_15-2-udp-组播" aria-label="Permalink to &quot;15.2 UDP 组播&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#adbac7;">在广播方式下，信息会发送到不需要该信息的主机从而浪费带宽资源，甚至引起广播风暴：而单播方式下，会因为数据包的多次重复而浪费带宽资源，同时，源主机的负荷会因为多次的数据复制而加大，所以，单播与广播对于多点发送问题有缺陷。在此情况下，组播技术就应用而生了。</span></span>
<span class="line"><span style="color:#adbac7;">组播类似于 QQ 群，如果把腾讯向 QQ 每个用户发送推送消息比作广播，那么组播就像是QQ 群一样，只有群内的用户才能收到消息。想要收到消息，我们得先加群。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">在广播方式下，信息会发送到不需要该信息的主机从而浪费带宽资源，甚至引起广播风暴：而单播方式下，会因为数据包的多次重复而浪费带宽资源，同时，源主机的负荷会因为多次的数据复制而加大，所以，单播与广播对于多点发送问题有缺陷。在此情况下，组播技术就应用而生了。</span></span>
<span class="line"><span style="color:#24292e;">组播类似于 QQ 群，如果把腾讯向 QQ 每个用户发送推送消息比作广播，那么组播就像是QQ 群一样，只有群内的用户才能收到消息。想要收到消息，我们得先加群。</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#adbac7;">QUdpSocket 类支持 UDP 组播，提供了 joinMulticastGroup 方法使本地主机加入多播组，leaveMulticastGroup 离开多播组。其他绑定端口，发送接收功能与 UDP 单播和广播完全一样。实际上我们在上一个实例学会使用 joinMulticastGroup 和 leaveMulticastGroup 的应用即可！</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">QUdpSocket 类支持 UDP 组播，提供了 joinMulticastGroup 方法使本地主机加入多播组，leaveMulticastGroup 离开多播组。其他绑定端口，发送接收功能与 UDP 单播和广播完全一样。实际上我们在上一个实例学会使用 joinMulticastGroup 和 leaveMulticastGroup 的应用即可！</span></span></code></pre></div><h3 id="案例-udp-单播与广播应用" tabindex="-1">案例：UDP 单播与广播应用 <a class="header-anchor" href="#案例-udp-单播与广播应用" aria-label="Permalink to &quot;案例：UDP 单播与广播应用&quot;">​</a></h3><h3 id="_15-3-qt网络下载" tabindex="-1">15.3 qt网络下载 <a class="header-anchor" href="#_15-3-qt网络下载" aria-label="Permalink to &quot;15.3 qt网络下载&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#adbac7;">Qt 网 络 模 块 还 提 供 了 直 接 访 问 如 HTTP ， FTP 等 网 络 协 议 的 类 ， 这 些 类 是QNetworkAccessManager、 QNetworkRequest 和 QNetworkReply。</span></span>
<span class="line"><span style="color:#adbac7;">由 QNetworkRequest 类设置一个 URL 地址发起网络协议请求， QNetworkRequest 类保存要用 QNetworkAccessManager 发送的请求。 QNetworkRequest 是网络访问 API 的一部分，是一个持有通过网络发送请求所需信息的类。它包含一个 URL 和一些可用于修改请求的辅助信息。</span></span>
<span class="line"><span style="color:#adbac7;">QNetworkAccessManager 类允许应用程序发送网络请求并接收响应。 在 QNetworkRequest发起网络请求后， QNetworkAccessManager 负责发送网络请求，创建网络响应。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Qt 网 络 模 块 还 提 供 了 直 接 访 问 如 HTTP ， FTP 等 网 络 协 议 的 类 ， 这 些 类 是QNetworkAccessManager、 QNetworkRequest 和 QNetworkReply。</span></span>
<span class="line"><span style="color:#24292e;">由 QNetworkRequest 类设置一个 URL 地址发起网络协议请求， QNetworkRequest 类保存要用 QNetworkAccessManager 发送的请求。 QNetworkRequest 是网络访问 API 的一部分，是一个持有通过网络发送请求所需信息的类。它包含一个 URL 和一些可用于修改请求的辅助信息。</span></span>
<span class="line"><span style="color:#24292e;">QNetworkAccessManager 类允许应用程序发送网络请求并接收响应。 在 QNetworkRequest发起网络请求后， QNetworkAccessManager 负责发送网络请求，创建网络响应。</span></span></code></pre></div><h3 id="案例-下载小图片" tabindex="-1">案例：下载小图片 <a class="header-anchor" href="#案例-下载小图片" aria-label="Permalink to &quot;案例：下载小图片&quot;">​</a></h3><p>本例目的：了解 QNetworkAccessManager、 QNetworkRequest 和 QNetworkReply 类的使用。</p><p>本例大体流程，设置一个下载图片的 URL，通过 networkReply 处理响应后，从流中读取图片的数据，然后保存到本地。</p>`,16);function U(a,D,v,y,_,q){const o=p,l=k("ClientOnly");return t(),r("div",null,[m,i(l,null,{default:d(()=>{var e,s;return[(((e=a.$frontmatter)==null?void 0:e.aside)??!0)&&(((s=a.$frontmatter)==null?void 0:s.showArticleMetadata)??!0)?(t(),g(o,{key:0,article:a.$frontmatter},null,8,["article"])):P("",!0)]}),_:1}),Q])}const M=c(b,[["render",U]]);export{f as __pageData,M as default};
