import{_ as r}from"./chunks/ArticleMetadata.C_HfcoCZ.js";import{_ as p,C as o,c as k,o as e,k as l,G as d,P as c,a as g,w as u,b as m,e as A}from"./chunks/framework.BbsDpi52.js";import"./chunks/md5.CF1HUy9Q.js";const N=JSON.parse('{"title":"基础数据结构","description":"","frontmatter":{"title":"基础数据结构","author":"阿源","date":"2023/03/03 12:00","categories":["数据结构与算法"],"tags":["数据结构与算法"]},"headers":[],"relativePath":"courses/algorithm/01-左程云算法基础/03-基础数据结构.md","filePath":"courses/algorithm/01-左程云算法基础/03-基础数据结构.md","lastUpdated":1713341239000}'),_={name:"courses/algorithm/01-左程云算法基础/03-基础数据结构.md"};function y(s,a,C,D,B,b){const n=r,h=o("ClientOnly");return e(),k("div",null,[a[0]||(a[0]=l("h1",{id:"基础数据结构",tabindex:"-1"},[g("基础数据结构 "),l("a",{class:"header-anchor",href:"#基础数据结构","aria-label":'Permalink to "基础数据结构"'},"​")],-1)),d(h,null,{default:u(()=>{var i,t;return[(((i=s.$frontmatter)==null?void 0:i.aside)??!0)&&(((t=s.$frontmatter)==null?void 0:t.showArticleMetadata)??!0)?(e(),m(n,{key:0,article:s.$frontmatter},null,8,["article"])):A("",!0)]}),_:1}),a[1]||(a[1]=c(`<h2 id="_1-单链表" tabindex="-1">1. 单链表 <a class="header-anchor" href="#_1-单链表" aria-label="Permalink to &quot;1. 单链表&quot;">​</a></h2><h2 id="_2-栈和队列" tabindex="-1">2. 栈和队列 <a class="header-anchor" href="#_2-栈和队列" aria-label="Permalink to &quot;2. 栈和队列&quot;">​</a></h2><h3 id="_2-1-如何使用栈实现队列" tabindex="-1">2.1 如何使用栈实现队列 <a class="header-anchor" href="#_2-1-如何使用栈实现队列" aria-label="Permalink to &quot;2.1 如何使用栈实现队列&quot;">​</a></h3><ul><li>比如：实现一个图的<strong>广度优先</strong>遍历，用<strong>栈</strong>来实现（要队列）</li><li>用两个栈，第一个栈用来存，当用户需要数据时，导入到第二个栈中(一次性倒完)，这样顺序就对了</li><li>如果第二个栈没拿完，就不能够导入数据到第二个</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// push栈向pop栈倒入数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> pushToPop</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (stackPop.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">empty</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">                while</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">stackPush.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">empty</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                    stackPop.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(stackPush.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span></code></pre></div><h3 id="_2-2-如何使用队列实现栈" tabindex="-1">2.2 如何使用队列实现栈 <a class="header-anchor" href="#_2-2-如何使用队列实现栈" aria-label="Permalink to &quot;2.2 如何使用队列实现栈&quot;">​</a></h3><ul><li>两个队列交换着使用</li><li>对于加入数据，在当前有数据的那个队列加入即可</li><li>当用户需要弹出时，将当前队列的前n-1个数据入队到另一个空队列，然后最后一个数据出队</li></ul><h2 id="_3-递归" tabindex="-1">3.递归 <a class="header-anchor" href="#_3-递归" aria-label="Permalink to &quot;3.递归&quot;">​</a></h2><p>形如 T(N) = a * T(N/b) + O(N^d) 可以用Master公式来确定其时间复杂度</p><ul><li>log(b , a ) &lt; d ， 复杂度为O(N^d)</li><li>log(b, a) &gt; d , 复杂度为O（N^log(b,a)）</li><li>v iolog(b, a) = d, 复杂度为O（N^d * logN）</li></ul><h2 id="哈希表和红黑树" tabindex="-1">哈希表和红黑树 <a class="header-anchor" href="#哈希表和红黑树" aria-label="Permalink to &quot;哈希表和红黑树&quot;">​</a></h2><p>TreeMap O(logN)</p>`,12))])}const v=p(_,[["render",y]]);export{N as __pageData,v as default};
