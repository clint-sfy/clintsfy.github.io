import{_ as t}from"./chunks/ArticleMetadata.59a467b2.js";import{_ as r,v as l,b as c,t as i,O as y,F as o,L as h,R as d,M as u,C as A,B as _}from"./chunks/framework.5cbdba25.js";import"./chunks/md5.02486a14.js";const q=JSON.parse('{"title":"基础数据结构","description":"","frontmatter":{"title":"基础数据结构","author":"阿源","date":"2023/03/03 12:00","categories":["数据结构与算法"],"tags":["数据结构与算法"]},"headers":[],"relativePath":"courses/algorithm/01-左程云算法基础/03-基础数据结构.md","filePath":"courses/algorithm/01-左程云算法基础/03-基础数据结构.md","lastUpdated":1691397650000}'),m={name:"courses/algorithm/01-左程云算法基础/03-基础数据结构.md"},D=o("h1",{id:"基础数据结构",tabindex:"-1"},[h("基础数据结构 "),o("a",{class:"header-anchor",href:"#基础数据结构","aria-label":'Permalink to "基础数据结构"'},"​")],-1),C=d(`<h2 id="_1-单链表" tabindex="-1">1. 单链表 <a class="header-anchor" href="#_1-单链表" aria-label="Permalink to &quot;1. 单链表&quot;">​</a></h2><h2 id="_2-栈和队列" tabindex="-1">2. 栈和队列 <a class="header-anchor" href="#_2-栈和队列" aria-label="Permalink to &quot;2. 栈和队列&quot;">​</a></h2><h3 id="_2-1-如何使用栈实现队列" tabindex="-1">2.1 如何使用栈实现队列 <a class="header-anchor" href="#_2-1-如何使用栈实现队列" aria-label="Permalink to &quot;2.1 如何使用栈实现队列&quot;">​</a></h3><ul><li>比如：实现一个图的<strong>广度优先</strong>遍历，用<strong>栈</strong>来实现（要队列）</li><li>用两个栈，第一个栈用来存，当用户需要数据时，导入到第二个栈中(一次性倒完)，这样顺序就对了</li><li>如果第二个栈没拿完，就不能够导入数据到第二个</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#768390;">// push栈向pop栈倒入数据</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#F47067;">private</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">pushToPop</span><span style="color:#ADBAC7;">() {</span></span>
<span class="line"><span style="color:#ADBAC7;">            </span><span style="color:#F47067;">if</span><span style="color:#ADBAC7;"> (stackPop.</span><span style="color:#DCBDFB;">empty</span><span style="color:#ADBAC7;">()) {</span></span>
<span class="line"><span style="color:#ADBAC7;">                </span><span style="color:#F47067;">while</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">!</span><span style="color:#ADBAC7;">stackPush.</span><span style="color:#DCBDFB;">empty</span><span style="color:#ADBAC7;">()) {</span></span>
<span class="line"><span style="color:#ADBAC7;">                    stackPop.</span><span style="color:#DCBDFB;">push</span><span style="color:#ADBAC7;">(stackPush.</span><span style="color:#DCBDFB;">pop</span><span style="color:#ADBAC7;">());</span></span>
<span class="line"><span style="color:#ADBAC7;">                }</span></span>
<span class="line"><span style="color:#ADBAC7;">            }</span></span>
<span class="line"><span style="color:#ADBAC7;">        }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// push栈向pop栈倒入数据</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">pushToPop</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (stackPop.</span><span style="color:#6F42C1;">empty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">stackPush.</span><span style="color:#6F42C1;">empty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">                    stackPop.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(stackPush.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span></code></pre></div><h3 id="_2-2-如何使用队列实现栈" tabindex="-1">2.2 如何使用队列实现栈 <a class="header-anchor" href="#_2-2-如何使用队列实现栈" aria-label="Permalink to &quot;2.2 如何使用队列实现栈&quot;">​</a></h3><ul><li>两个队列交换着使用</li><li>对于加入数据，在当前有数据的那个队列加入即可</li><li>当用户需要弹出时，将当前队列的前n-1个数据入队到另一个空队列，然后最后一个数据出队</li></ul><h2 id="_3-递归" tabindex="-1">3.递归 <a class="header-anchor" href="#_3-递归" aria-label="Permalink to &quot;3.递归&quot;">​</a></h2><p>形如 T(N) = a * T(N/b) + O(N^d) 可以用Master公式来确定其时间复杂度</p><ul><li>log(b , a ) &lt; d ， 复杂度为O(N^d)</li><li>log(b, a) &gt; d , 复杂度为O（N^log(b,a)）</li><li>v iolog(b, a) = d, 复杂度为O（N^d * logN）</li></ul><h2 id="哈希表和红黑树" tabindex="-1">哈希表和红黑树 <a class="header-anchor" href="#哈希表和红黑树" aria-label="Permalink to &quot;哈希表和红黑树&quot;">​</a></h2><p>TreeMap O(logN)</p>`,12);function B(s,b,g,f,k,P){const p=t,e=u("ClientOnly");return l(),c("div",null,[D,i(e,null,{default:y(()=>{var a,n;return[(((a=s.$frontmatter)==null?void 0:a.aside)??!0)&&(((n=s.$frontmatter)==null?void 0:n.showArticleMetadata)??!0)?(l(),A(p,{key:0,article:s.$frontmatter},null,8,["article"])):_("",!0)]}),_:1}),C])}const O=r(m,[["render",B]]);export{q as __pageData,O as default};
